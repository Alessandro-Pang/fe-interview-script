[
  {
    "question": "Vue组件中data属性为何必须是函数？",
    "description": "在Vue组件中，data属性被设计为返回一个对象的函数而非直接使用对象。这样做的主要目的是什么？请解释其背后的原因和必要性。",
    "tag": ["Vue原理", "组件设计", "响应式系统"]
  },
  {
    "question": "Vue如何解决对象新增属性不触发视图更新的问题？",
    "description": "当给Vue响应式对象动态添加新属性时，视图可能不会自动更新。请说明这种情况的原因，并列举Vue提供的解决方案及其实现原理。",
    "tag": ["响应式系统", "Vue API", "数据观测"]
  },
  {
    "question": "计算属性与方法的本质区别是什么？",
    "description": "请从缓存机制、响应式依赖追踪和使用场景等方面，详细说明Vue中计算属性(computed)与方法(methods)的核心区别。",
    "tag": ["计算属性", "性能优化", "响应式原理"]
  },
  {
    "question": "计算属性与data属性同名会引发什么问题？",
    "description": "如果计算属性与data中的属性同名，会导致什么问题？请解释Vue内部如何处理这种情况及其潜在影响。",
    "tag": ["命名冲突", "响应式系统", "Vue警告"]
  },
  {
    "question": "Vue对$或_开头属性有何特殊处理？",
    "description": "在Vue响应式系统中，以$或_开头的属性具有什么样的特殊行为？这种设计主要出于哪些考虑？",
    "tag": ["响应式系统", "Vue内部机制", "属性代理"]
  },
  {
    "question": "如何理解Vue的单向数据流与双向绑定？",
    "description": "请解释Vue中单向数据流的设计原则与v-model实现的双向数据绑定的关系，说明二者如何共存以及适用的不同场景。",
    "tag": ["数据流", "双向绑定", "设计模式"]
  },
  {
    "question": "Vue的MVVM模式与MVC/MVP有何区别？",
    "description": "从架构模式角度分析，Vue的MVVM实现与传统的MVC/MVP模式在职责划分、数据流管理和视图控制等方面有哪些核心差异？",
    "tag": ["设计模式", "MVVM", "架构对比"]
  },
  {
    "question": "Vue生命周期阶段划分及作用",
    "description": "请完整列举Vue组件的生命周期钩子函数，并说明每个阶段的核心作用（如数据观测、DOM挂载、更新触发等）。这些阶段的划分对组件行为控制有何意义？",
    "tag": ["生命周期钩子", "组件生命周期", "初始化流程"]
  },
  {
    "question": "created与mounted钩子的差异与应用",
    "description": "created和mounted生命周期钩子分别在什么时间节点触发？从数据初始化、DOM访问权限、第三方库集成等角度，说明两者的典型应用场景及使用限制。",
    "tag": ["生命周期钩子", "异步请求", "DOM操作"]
  },
  {
    "question": "异步数据请求的最佳生命周期阶段",
    "description": "在Vue组件中发起异步数据请求时，为什么推荐在特定生命周期阶段执行？从白屏时间优化、数据可用性、DOM渲染顺序等维度解释选择该阶段的合理性。",
    "tag": ["异步请求", "性能优化", "数据获取"]
  },
  {
    "question": "强制初始化执行watch监听的方法",
    "description": "当需要在组件初始化时立即触发watch监听器而非等待数据变化时，Vue提供了哪些实现方式？请说明配置参数或替代方案的具体用法及其原理。",
    "tag": ["watch监听", "响应式系统", "初始化配置"]
  },
  {
    "question": "DOM渲染完成的生命周期阶段",
    "description": "在哪个生命周期钩子中可以确认DOM已渲染完毕？请结合虚拟DOM的patch过程，说明该阶段前后DOM状态的变化及访问渲染后DOM的安全方法。",
    "tag": ["DOM渲染", "生命周期阶段", "挂载完成"]
  },
  {
    "question": "v-show与v-if的原理差异及适用场景",
    "description": "请从DOM结构、渲染机制、性能消耗等角度说明v-show和v-if的底层实现差异，并举例说明在哪些具体场景下应优先选择其中一个指令。",
    "tag": ["指令原理", "条件渲染", "性能优化"]
  },
  {
    "question": "避免同时使用v-if和v-for的原因",
    "description": "根据Vue官方风格指南，为什么建议避免在同一元素上同时使用v-if和v-for？请解释其优先级问题可能导致的渲染异常或性能损耗的具体表现。",
    "tag": ["指令冲突", "渲染优先级", "最佳实践"]
  },
  {
    "question": "v-for中key属性的核心作用",
    "description": "在v-for指令中指定key属性对Vue的虚拟DOM算法有何重要意义？请结合列表更新时的节点复用机制，说明未正确使用key可能导致的问题。",
    "tag": ["列表渲染", "虚拟DOM", "diff算法"]
  },
  {
    "question": "v-cloak和v-pre指令的典型应用",
    "description": "请描述v-cloak指令解决模板闪烁问题的具体实现方式，以及v-pre指令在跳过编译过程的特殊场景下的性能优化价值。",
    "tag": ["指令特性", "编译优化", "用户体验"]
  },
  {
    "question": "保留模板中HTML注释的方法",
    "description": "在Vue模板中默认会移除HTML注释，若需要保留生产环境的注释内容，应当通过何种配置或特殊语法实现？请说明其实现原理。",
    "tag": ["模板编译", "注释处理", "配置选项"]
  },
  {
    "question": "Vue模板引擎的实现原理",
    "description": "请解析Vue将模板语法转换为可执行渲染函数的核心过程，包括AST抽象语法树构建、静态节点优化、代码生成等关键环节的作用。",
    "tag": ["模板编译", "虚拟DOM", "编译器原理"]
  },
  {
    "question": "v-model的实现机制与修饰符",
    "description": "详细说明v-model在不同表单元素上的双向绑定实现原理，并解释.lazy、.number、.trim等修饰符如何通过事件劫持改变默认更新行为。",
    "tag": ["双向绑定", "表单处理", "修饰符原理"]
  },
  {
    "question": "组件模板单根限制与Vue3变化",
    "description": "在Vue2中为什么强制要求组件模板必须包含单个根元素？Vue3版本对此做出了哪些改进？请从虚拟DOM更新机制角度解释这一限制的成因与演进。",
    "tag": ["组件设计", "Vue3特性", "模板编译"]
  },
  {
    "question": "Vue组件通信方式及应用场景",
    "description": "请列举至少5种Vue组件间的通信方式，并分别说明props/emit、全局事件总线、Vuex/Pinia状态管理、provide/inject以及$refs等方案的最佳适用场景及潜在缺陷。",
    "tag": ["组件通信", "状态管理", "设计模式"]
  },
  {
    "question": "插槽机制与高级应用",
    "description": "从内容分发到作用域透传，详细说明Vue插槽系统的设计哲学。请举例说明具名插槽、作用域插槽在构建高阶组件时的特殊应用场景及其实现原理。",
    "tag": ["插槽系统", "组件复用", "作用域透传"]
  },
  {
    "question": "子组件实例与DOM访问方法",
    "description": "当需要直接操作子组件内部方法或访问特定DOM元素时，Vue提供了哪些安全可靠的实现方式？请解释$refs工作机制及其在组合式API中的使用变化。",
    "tag": ["组件引用", "DOM操作", "组合式API"]
  },
  {
    "question": "组件name属性的核心作用",
    "description": "组件选项中的name属性在keep-alive缓存匹配、递归组件调用、开发者工具调试等方面分别起到什么关键作用？Vue3中name属性的使用有哪些注意事项？",
    "tag": ["组件配置", "组件缓存", "调试优化"]
  },
  {
    "question": "动态组件与异步加载原理",
    "description": "解析component动态组件通过is属性切换的实现机制，并说明异步组件如何结合Webpack代码分割实现按需加载。Vue3中Suspense组件如何增强异步加载体验？",
    "tag": ["动态组件", "代码分割", "性能优化"]
  },
  {
    "question": ".vue文件作为组件的实现原理",
    "description": "为什么Vue单文件组件(SFC)必须以.vue为后缀？解析webpack+vue-loader或Vite如何将其编译为JavaScript模块。是否支持.jsx/.tsx等其他扩展名实现相同功能？",
    "tag": ["SFC原理", "构建工具", "编译流程"]
  },
  {
    "question": "组件/插件/插槽的核心区别",
    "description": "从功能边界角度阐述Vue中组件(Component)、插件(Plugin)、插槽(Slot)三者的本质区别，举例说明在哪些场景下应选择使用插件而非全局组件扩展功能。",
    "tag": ["概念辨析", "功能扩展", "架构设计"]
  },
  {
    "question": "路由404页面配置方法",
    "description": "在Vue Router中如何配置未匹配路由时的404页面？请说明通配符路由的两种写法（'*'与'/:pathMatch(.*)*'）的区别，并解释为何需要将404路由配置在路由列表末尾。",
    "tag": ["路由配置", "错误处理", "路径匹配"]
  },
  {
    "question": "hash与history路由模式对比",
    "description": "从URL结构、SEO友好性、服务器配置要求等维度，详细说明hash模式与history模式的核心差异。当使用history模式时，为什么需要配置服务器fallback策略？",
    "tag": ["路由模式", "浏览器兼容", "服务器配置"]
  },
  {
    "question": "路由参数params与query的获取",
    "description": "在动态路由匹配中，如何通过$route对象获取路径参数(params)和查询参数(query)？请结合路由配置中的path定义，说明两种参数类型的适用场景及编码差异。",
    "tag": ["参数传递", "URL解析", "路由配置"]
  },
  {
    "question": "router-link的active-class作用",
    "description": "router-link组件默认应用的active-class有何功能意义？请说明精确匹配路由时exact-active-class属性的触发机制，并给出导航高亮的典型实现方案。",
    "tag": ["导航样式", "路由激活", "CSS控制"]
  },
  {
    "question": "编程式导航与声明式导航区别",
    "description": "对比router.push()等编程式导航与<router-link>声明式导航的底层实现差异，说明在哪些交互场景下必须使用编程式导航，并列举导航守卫对两种方式的影响。",
    "tag": ["导航方式", "路由跳转", "交互控制"]
  },
  {
    "question": "路由跳转与location.href的本质区别",
    "description": "为什么在Vue单页应用中推荐使用路由跳转而非直接修改location.href？从页面重载、体验优化、路由守卫等角度说明两者的根本性差异。",
    "tag": ["SPA原理", "页面跳转", "性能优化"]
  },
  {
    "question": "watch与计算属性的核心区别",
    "description": "从依赖追踪、缓存机制、异步处理能力等维度，详细说明watch和计算属性(computed)在响应式系统中的设计差异。当处理复杂数据联动时，应如何根据性能优化原则选择合适方案？",
    "tag": ["响应式原理", "性能优化", "数据监听"]
  },
  {
    "question": "自定义指令的典型应用场景",
    "description": "请列举至少三种适合使用Vue自定义指令实现的场景（如DOM操作、权限控制等），并说明为何这些场景更适合用指令而非组件封装。给出实现图片懒加载指令的具体代码设计思路。",
    "tag": ["指令系统", "DOM操作", "功能封装"]
  },
  {
    "question": "过滤器(filter)的现代化替代方案",
    "description": "在Vue3中移除过滤器(filter)特性后，应如何迁移原有格式化逻辑？请对比全局属性、组合式函数、计算属性等替代方案的优劣，并说明在Vue2遗留项目中安全使用过滤器的注意事项。",
    "tag": ["Vue迁移", "代码重构", "全局方法"]
  },
  {
    "question": "nextTick的异步更新原理",
    "description": "结合JavaScript事件循环机制，解析Vue中nextTick如何实现DOM更新后的回调触发。为何连续修改数据时需要使用nextTick保证获取最新DOM状态？说明微任务队列在此过程中的作用。",
    "tag": ["异步机制", "DOM更新", "事件循环"]
  },
  {
    "question": "Scoped CSS的模块化实现",
    "description": "Vue单文件组件的scoped特性如何通过PostCSS实现CSS模块化？分析属性选择器策略的优缺点，并说明使用CSS Modules与scoped CSS在样式隔离机制上的本质区别。",
    "tag": ["样式隔离", "构建工具", "PostCSS"]
  },
  {
    "question": "表单与事件修饰符应用原理",
    "description": "解析v-model的.lazy修饰符如何通过input事件改为change事件实现延迟更新，并对比.stop/.prevent等事件修饰符与原生event.preventDefault()在事件传播控制上的实现差异。",
    "tag": ["表单处理", "事件系统", "修饰符原理"]
  },
  {
    "question": "Vue风格指南核心规范",
    "description": "Vue官方风格指南中强调的A级（必要）和B级（强烈推荐）规范包含哪些关键内容？请具体说明组件命名、v-for键值、prop定义等规范的约束条件及其背后的工程化考量。",
    "tag": ["编码规范", "最佳实践", "代码维护"]
  },
  {
    "question": "组件data状态重置方法",
    "description": "当需要将组件内部状态恢复到初始值时，为什么直接给data对象赋值可能破坏响应式？请演示通过Object.assign合并或重新执行data函数的安全重置方案及其原理。",
    "tag": ["状态管理", "组件设计", "响应式原理"]
  },
  {
    "question": "键盘事件监听与修饰符",
    "description": "对比@keyup.enter原生事件监听与Vue的键盘修饰符系统，说明如何通过全局config.keyCodes注册自定义按键别名。哪些特殊按键系统（如ESC）需要特别注意浏览器兼容性？",
    "tag": ["事件处理", "键盘交互", "修饰符系统"]
  },
  {
    "question": "模板中$event对象的使用规范",
    "description": "在@click事件中直接使用$event与在自定义事件中使用$event有何本质区别？请说明同时传递$event和其他参数时的正确模板写法，并解释事件对象代理机制。",
    "tag": ["事件系统", "模板语法", "参数传递"]
  },
  {
    "question": "组件命名规范与约定",
    "description": "为什么Vue官方推荐组件名使用PascalCase或kebab-case格式？从全局注册、递归组件、开发者工具识别等角度说明统一命名规范的重要性和具体实施建议。",
    "tag": ["组件命名", "工程规范", "可维护性"]
  },
  {
    "question": "避免data与方法同名的原因",
    "description": "如果组件data属性与methods中的方法同名，会导致什么运行时问题？请从Vue实例属性合并策略的角度，解释这种命名冲突如何破坏预期行为并影响响应式追踪。",
    "tag": ["命名冲突", "响应式系统", "实例属性"]
  },
  {
    "question": "Vue2对IE的兼容性支持范围",
    "description": "Vue2官方宣称支持的Internet Explorer最低版本是什么？为实现兼容需要配置哪些polyfill（如Promise/Object.assign等）？请说明在webpack工程中保证IE兼容性的核心配置步骤。",
    "tag": ["浏览器兼容", "构建配置", "Vue2特性"]
  },
  {
    "question": "v-html指令的XSS风险与防护",
    "description": "使用v-html指令渲染动态HTML内容时，存在哪些潜在的安全漏洞？列举三种替代方案（如模板插值、组件封装等）说明如何规避XSS攻击，并解释Vue为何不默认提供HTML净化功能。",
    "tag": ["XSS防护", "安全最佳实践", "模板语法"]
  },
  {
    "question": "模板编译与虚拟DOM的协同机制",
    "description": "从模板字符串到虚拟DOM节点树的生成过程中，Vue编译器如何通过AST转换生成渲染函数？请结合patch算法说明虚拟DOM在后续更新阶段如何实现高效比对。",
    "tag": ["模板编译", "虚拟DOM", "渲染机制"]
  },
  {
    "question": "响应式依赖收集的实现原理",
    "description": "Vue通过Object.defineProperty进行数据劫持时，如何通过Dep类和Watcher实例实现依赖收集？请描述从数据读取到依赖关系建立的完整链路及触发更新的回调流程。",
    "tag": ["响应式原理", "依赖收集", "数据绑定"]
  },
  {
    "question": "Vue对比原生开发的核心优势",
    "description": "相较于原生JavaScript操作DOM，Vue在开发效率、维护成本、性能优化等方面提供哪些核心价值？请结合响应式系统、组件化架构、生态工具链等特性进行系统性对比分析。",
    "tag": ["框架对比", "开发效率", "工程化"]
  }
]
